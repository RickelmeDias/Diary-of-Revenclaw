# Paradigms of Algorithm Design

Strategies for approaching a problem and attempting to model its solution.

#### List of Paradigms:

- [Induction](https://proofwiki.org/wiki/Principle_of_Finite_Induction) and [Recursion](https://www.freecodecamp.org/news/understanding-recursion-in-programming/);

- Brute Force: This approach involves trying every possible solution to a problem until the correct one is found. It is often used when the problem is small and the time complexity is not a concern _(it has a high complexity.)_;

- Backtracking: This approach involves building a solution by trying out different possible options and then undoing the choices that don't lead to a solution. This technique is often used for problems where the solution can be represented as a sequence of choices;

- Divide and Conquer: This approach involves breaking down a problem into smaller sub-problems that can be solved independently. This technique is often used for problems that can be divided into similar and simpler sub-problems;

- Dynamic Programming: This approach involves solving a problem by breaking it down into smaller sub-problems and then solving each sub-problem only once. This technique is often used for optimization problems, such as finding the shortest path or maximizing profit;

- Greedy Algorithms: This approach involves making the locally optimal choice at each step with the hope of finding a global optimum solution. This technique is often used for optimization problems where a solution can be built step by step;

- Heuristic Algorithms: This approach involves using a set of guidelines or rules to find a good solution to a problem. This technique is often used for problems where an optimal solution is not required, but a good solution is sufficient;

- Randomized Algorithms: This approach involves using randomness to solve problems efficiently. This technique is often used for problems where a deterministic algorithm would take too long to run.
